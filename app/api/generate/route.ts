import { NextRequest, NextResponse } from "next/server";

type ParsedParams = {
  style: string;
  floors: number;
  floorHeight: number;
  width: number;
  depth: number;
  facade: string;
  roof: string;
  entrance: string;
  balconies: boolean;
  windows: "grid" | "tall" | "bay";
  seed: number;
};

function clamp(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, n));
}

function extractNumber(text: string, fallback: number): number {
  const m = text.match(/(\d+(\.\d+)?)/);
  if (!m) return fallback;
  return parseFloat(m[1]);
}

function parsePrompt(prompt: string): ParsedParams {
  const p = prompt.toLowerCase();
  const params: ParsedParams = {
    style: "modern",
    floors: 8,
    floorHeight: 3.0,
    width: 20,
    depth: 12,
    facade: "glass",
    roof: "flat",
    entrance: "simple",
    balconies: false,
    windows: "grid",
    seed: Math.floor(Math.random() * 10_000)
  };

  // style
  if (p.includes("haussmann") || p.includes("parisian") || p.includes("beaux-arts")) params.style = "haussmann";
  else if (p.includes("gothic")) params.style = "gothic";
  else if (p.includes("brutalist") || p.includes("brutalism")) params.style = "brutalist";
  else if (p.includes("classical") || p.includes("neoclassical")) params.style = "classical";
  else if (p.includes("mediterranean")) params.style = "mediterranean";
  else if (p.includes("art deco")) params.style = "art_deco";
  else if (p.includes("industrial")) params.style = "industrial";
  else if (p.includes("modern") || p.includes("contemporary")) params.style = "modern";

  // floors
  const floorsMatch = p.match(/(\d+)\s*(stories|storeys|storey|story|floors|floor)\b/);
  if (floorsMatch) params.floors = clamp(parseInt(floorsMatch[1], 10), 1, 120);

  // floor height
  const floorHeightMatch = p.match(/(floor\s*height|height\s*per\s*floor)\s*(is|:)?\s*(\d+(\.\d+)*)\s*(m|meters|metres)?/);
  if (floorHeightMatch) params.floorHeight = clamp(parseFloat(floorHeightMatch[3]), 2.5, 5.5);

  // width x depth
  const rectMatch = p.match(/(\d+(\.\d+)*)\s*[x?]\s*(\d+(\.\d+)*)\s*(m|meters|metres)/);
  if (rectMatch) {
    params.width = clamp(parseFloat(rectMatch[1]), 5, 200);
    params.depth = clamp(parseFloat(rectMatch[3]), 5, 200);
  } else {
    const wMatch = p.match(/(width|wide)\s*(is|:)?\s*(\d+(\.\d+)*)\s*(m|meters|metres)/);
    const dMatch = p.match(/(depth|deep)\s*(is|:)?\s*(\d+(\.\d+)*)\s*(m|meters|metres)/);
    if (wMatch) params.width = clamp(parseFloat(wMatch[3]), 5, 200);
    if (dMatch) params.depth = clamp(parseFloat(dMatch[3]), 5, 200);
  }

  // facade
  if (p.includes("curtain wall") || p.includes("glass")) params.facade = "glass";
  if (p.includes("stone")) params.facade = "stone";
  if (p.includes("brick")) params.facade = "brick";
  if (p.includes("concrete")) params.facade = "concrete";
  if (p.includes("plaster") || p.includes("stucco")) params.facade = "plaster";

  // roof
  if (p.includes("mansard")) params.roof = "mansard";
  else if (p.includes("gable")) params.roof = "gable";
  else if (p.includes("hip") || p.includes("hipped")) params.roof = "hip";
  else if (p.includes("flat")) params.roof = "flat";

  // entrance
  if (p.includes("revolving")) params.entrance = "revolving";
  else if (p.includes("arches") || p.includes("arch")) params.entrance = "arched";
  else if (p.includes("portico")) params.entrance = "portico";
  else if (p.includes("grand")) params.entrance = "grand";

  // balconies
  params.balconies = /balcony|balconies|balustrade/.test(p);

  // windows
  if (p.includes("tall windows") || p.includes("floor-to-ceiling")) params.windows = "tall";
  else if (p.includes("bay window") || p.includes("bay windows")) params.windows = "bay";
  else params.windows = "grid";

  // seed
  const seedMatch = p.match(/\bseed\s*(is|:)?\s*(\d+)\b/);
  if (seedMatch) params.seed = parseInt(seedMatch[2], 10);

  return params;
}

function buildBlenderScript(params: ParsedParams): string {
  const {
    style,
    floors,
    floorHeight,
    width,
    depth,
    facade,
    roof,
    entrance,
    balconies,
    windows,
    seed
  } = params;

  // Produce a robust, self-contained bpy script
  const code = `# Generated by Architect AI Assistant for Blender
# Style: ${style}
# Floors: ${floors}, Floor Height: ${floorHeight.toFixed(2)} m
# Footprint: ${width.toFixed(2)} m x ${depth.toFixed(2)} m
# Facade: ${facade}, Roof: ${roof}, Windows: ${windows}, Balconies: ${balconies ? "yes" : "no"}
# Entrance: ${entrance}
# Seed: ${seed}

import bpy
import bmesh
import random
from mathutils import Vector
from math import radians

random.seed(${seed})

def clear_selection():
    bpy.ops.object.select_all(action='DESELECT')

def delete_all_if_scene_is_empty():
    # Optional: keep user's scene, only clean if default cube exists alone
    pass

def ensure_material(name, base_color, metallic=0.0, roughness=0.5):
    if name in bpy.data.materials:
        return bpy.data.materials[name]
    m = bpy.data.materials.new(name)
    m.use_nodes = True
    nodes = m.node_tree.nodes
    bsdf = nodes.get("Principled BSDF")
    if bsdf:
        bsdf.inputs["Base Color"].default_value = (*base_color, 1.0)
        bsdf.inputs["Metallic"].default_value = metallic
        bsdf.inputs["Roughness"].default_value = roughness
    return m

def add_box(name, size_x, size_y, size_z, location=(0,0,0), material=None):
    bpy.ops.mesh.primitive_cube_add(size=1, location=location)
    obj = bpy.context.active_object
    obj.name = name
    obj.scale = (size_x/2, size_y/2, size_z/2)
    bpy.ops.object.transform_apply(scale=True)
    if material:
        if obj.data.materials:
            obj.data.materials[0] = material
        else:
            obj.data.materials.append(material)
    return obj

def add_facade_panel(width, height, depth, material):
    return add_box("FacadePanel", width, depth, height, material=material)

def add_window(width, height, depth, frame_mat, glass_mat, vertical_divs=2, horizontal_divs=2):
    # Frame
    frame = add_box("WindowFrame", width, depth, height, material=frame_mat)
    # Glass pane
    glass = add_box("WindowGlass", width*0.9, depth*0.2, height*0.9, material=glass_mat)
    glass.parent = frame
    glass.location.z += height*0.01
    return frame

def create_footprint(width, depth):
    bpy.ops.mesh.primitive_plane_add(size=1)
    base = bpy.context.active_object
    base.name = "Footprint"
    base.scale = (width/2, depth/2, 1)
    bpy.ops.object.transform_apply(scale=True)
    return base

def extrude_building(base, height, wall_mat):
    bpy.context.view_layer.objects.active = base
    bpy.ops.object.mode_set(mode='EDIT')
    bm = bmesh.from_edit_mesh(base.data)
    geom = bm.faces[:]
    ret = bmesh.ops.extrude_face_region(bm, geom=geom)
    verts = [v for v in ret['geom'] if isinstance(v, bmesh.types.BMVert)]
    for v in verts:
        v.co.z += height
    bmesh.update_edit_mesh(base.data)
    bpy.ops.object.mode_set(mode='OBJECT')
    # Convert to solid walls thickness
    bpy.ops.object.modifier_add(type='SOLIDIFY')
    base.modifiers[-1].thickness = 0.3
    # Assign material
    if base.data.materials:
        base.data.materials[0] = wall_mat
    else:
        base.data.materials.append(wall_mat)
    return base

def add_repeating_windows(wall_obj, width, depth, floors, floor_height, style_variant):
    frame_mat = ensure_material("Frame_Metal", (0.15,0.15,0.16), metallic=0.7, roughness=0.2)
    glass_mat = ensure_material("Glass", (0.6,0.8,1.0), metallic=0.0, roughness=0.02)
    # Determine window dims
    if style_variant == "tall":
        win_w, win_h = 1.6, floor_height * 0.8
    elif style_variant == "bay":
        win_w, win_h = 2.2, floor_height * 0.7
    else:
        win_w, win_h = 1.2, floor_height * 0.6
    margin_x = 0.8
    margin_y = 0.3
    usable_w = width - 2*margin_x
    count_x = max(1, int(usable_w // (win_w + 0.6)))
    step_x = usable_w / count_x
    for floor in range(floors):
        z = (floor+0.5)*floor_height
        for i in range(count_x):
            x = -width/2 + margin_x + (i+0.5)*step_x
            win = add_window(win_w, win_h, 0.2, frame_mat, glass_mat)
            win.location = (x, 0, z)
            # Attach via boolean or parent; keeping separate for editability
            win.parent = wall_obj

def add_balconies_if_needed(parent, width, depth, floors, floor_height, enabled):
    if not enabled:
        return
    slab_mat = ensure_material("Balcony_Slab", (0.7,0.7,0.72), metallic=0.0, roughness=0.7)
    rail_mat = ensure_material("Balcony_Rail", (0.1,0.1,0.12), metallic=0.6, roughness=0.3)
    balcony_depth = 1.1
    usable_w = width - 1.2
    count_x = max(1, int(usable_w // 3.2))
    step_x = usable_w / count_x
    for floor in range(1, floors):  # skip ground
        z = floor*floor_height + 0.15
        for i in range(count_x):
            x = -width/2 + 0.6 + (i+0.5)*step_x
            slab = add_box("BalconySlab", 2.4, balcony_depth, 0.1, location=(x, depth/2 + balcony_depth/2, z), material=slab_mat)
            rail = add_box("BalconyRail", 2.2, 0.05, 1.0, location=(x, depth/2 + balcony_depth + 0.02, z+0.5), material=rail_mat)
            slab.parent = parent
            rail.parent = parent

def add_entrance(parent, depth, entrance_type):
    door_mat = ensure_material("Door_Metal", (0.08,0.08,0.1), metallic=0.6, roughness=0.4)
    glass_mat = ensure_material("Door_Glass", (0.75,0.9,1.0), metallic=0.0, roughness=0.02)
    if entrance_type == "revolving":
        base = add_box("RevolvingDoorFrame", 2.8, 0.4, 2.5, material=door_mat)
        base.location = (0, -depth/2 - 0.2, 1.25)
        wing = add_box("RevolvingDoorGlass", 0.05, 1.2, 2.2, material=glass_mat)
        wing.location = (0, -depth/2 - 0.2, 1.1)
        wing.parent = base
        base.parent = parent
    elif entrance_type == "arched":
        base = add_box("ArchedEntrance", 3.2, 0.6, 3.2, material=door_mat)
        base.location = (0, -depth/2 - 0.3, 1.6)
        base.parent = parent
    elif entrance_type == "grand":
        frame = add_box("GrandPortal", 5.0, 0.6, 4.0, material=door_mat)
        frame.location = (0, -depth/2 - 0.3, 2.0)
        frame.parent = parent
    else:
        frame = add_box("Entrance", 2.0, 0.4, 2.3, material=door_mat)
        frame.location = (0, -depth/2 - 0.2, 1.15)
        frame.parent = parent

def add_roof(parent, width, depth, roof_type):
    roof_mat = ensure_material("Roof", (0.12,0.12,0.12), metallic=0.0, roughness=0.9)
    if roof_type == "mansard":
        cap = add_box("RoofCap", width, depth, 0.4, location=(0,0,0), material=roof_mat)
        cap.parent = parent
        # Add tilted sides (simplified)
        for sign_x in (-1,1):
            side = add_box("MansardSideX", width*0.2, depth, 0.6, material=roof_mat)
            side.location = (sign_x*(width/2 - width*0.1), 0, 0.3)
            side.rotation_euler.y = radians(15 * -sign_x)
            side.parent = parent
        for sign_y in (-1,1):
            side = add_box("MansardSideY", width, depth*0.2, 0.6, material=roof_mat)
            side.location = (0, sign_y*(depth/2 - depth*0.1), 0.3)
            side.rotation_euler.x = radians(15 * sign_y)
            side.parent = parent
    elif roof_type == "hip":
        cap = add_box("RoofHip", width, depth, 0.4, location=(0,0,0.0), material=roof_mat)
        cap.parent = parent
    elif roof_type == "gable":
        cap = add_box("RoofGable", width, depth, 0.4, location=(0,0,0.0), material=roof_mat)
        cap.parent = parent
    else:
        slab = add_box("RoofSlab", width, depth, 0.3, location=(0,0,0.0), material=roof_mat)
        slab.parent = parent

def main():
    clear_selection()
    # Base footprint and extrusion
    base = create_footprint(${width}, ${depth})
    wall_mat = ensure_material("Wall_${facade}".upper(), {
        "glass": (0.5,0.7,0.9),
        "stone": (0.7,0.68,0.62),
        "brick": (0.55,0.2,0.15),
        "concrete": (0.6,0.6,0.62),
        "plaster": (0.86,0.86,0.84)
    }.get("${facade}", (0.8,0.8,0.82)), metallic=0.0 if "${facade}"!="glass" else 0.2, roughness=0.65)
    height = ${floors} * ${floorHeight}
    tower = extrude_building(base, height, wall_mat)
    tower.name = "Building"

    # Windows on the Y+ facade only (front) for clarity; can be extended to all sides
    add_repeating_windows(tower, ${width}, ${depth}, ${floors}, ${floorHeight}, "${windows}")

    # Balconies
    add_balconies_if_needed(tower, ${width}, ${depth}, ${floors}, ${floorHeight}, ${"True" if balconies else "False"})

    # Entrance
    add_entrance(tower, ${depth}, "${entrance}")

    # Roof at top
    roof_empty = bpy.data.objects.new("RoofGroup", None)
    bpy.context.collection.objects.link(roof_empty)
    roof_empty.location = (0,0,${floors}*${floorHeight})
    add_roof(roof_empty, ${width}, ${depth}, "${roof}")

    # View tweaks: move camera if exists
    if bpy.data.objects.get("Camera"):
        cam = bpy.data.objects["Camera"]
        cam.location = (max(${width},${depth})*1.2, -max(${width},${depth})*1.6, ${floors}*${floorHeight}*0.6)
        cam.rotation_euler = (radians(65), 0, radians(35))

if __name__ == "__main__":
    main()
`;
  return code;
}

export async function POST(req: NextRequest) {
  const body = await req.json().catch(() => ({}));
  const prompt: string = (body?.prompt ?? "").toString();
  if (!prompt || !prompt.trim()) {
    return NextResponse.json({ error: "Missing prompt" }, { status: 400 });
  }
  const params = parsePrompt(prompt);
  const code = buildBlenderScript(params);
  const filename = `building_${params.style}_${params.floors}f_${params.width}x${params.depth}_seed${params.seed}.py`.replace(/\s+/g, "_");
  return NextResponse.json({ code, parameters: params, filename });
}

